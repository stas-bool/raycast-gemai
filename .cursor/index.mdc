---
description: 
globs: 
alwaysApply: false
---
# Raycast GemAI - Правила разработки расширения

## Обзор проекта
Raycast GemAI - универсальное расширение для Raycast, предоставляющее AI-ассистент с поддержкой Google Gemini и OpenAI моделей. Проект написан на TypeScript с использованием React и Raycast API.

**Стек технологий:**
- TypeScript (строгий режим)
- React (функциональные компоненты)
- Raycast API
- Google Gemini API
- OpenAI API

## Архитектурные принципы

### Универсальная AI архитектура
- Используйте единый интерфейс `AIProvider` для всех AI провайдеров
- Поддерживайте автоматическое переключение моделей (o1 → GPT-4o для изображений)
- Обрабатывайте reasoning модели (o1-preview, o1-mini) с thinking tokens
- Всегда используйте потоковую передачу ответов для UX

### Структура проекта
```
src/
├── core/              # Основная бизнес-логика
│   ├── aiProvider.ts  # Провайдеры AI (Gemini/OpenAI)
│   ├── types.ts       # Типы и интерфейсы
│   ├── gemai.tsx      # Главный UI компонент
│   └── utils.ts       # Утилиты
└── [command].ts       # Файлы команд Raycast
```

## Стандарты кода

### TypeScript правила
- Используйте строгую типизацию TypeScript
- Избегайте `any`, `unknown` предпочтительнее
- Определяйте интерфейсы в `src/core/types.ts`
- Используйте `AIConfig` как основной интерфейс конфигурации
- Следуйте паттерну `RequestStats` для метрик

### Функциональное программирование
- Предпочитайте функциональные компоненты
- Используйте хуки вместо классов
- Избегайте мутации состояния
- Применяйте композицию над наследованием

### Именование конвенции
- `camelCase` для переменных и функций
- `PascalCase` для компонентов, интерфейсов и типов
- `UPPER_SNAKE_CASE` для констант
- Префикс `CMD_` для констант команд
- Используйте описательные имена с вспомогательными глаголами (isLoading, hasError)

### Структура файлов
- Один главный компонент/класс на файл
- Экспортируйте по умолчанию главные компоненты
- Используйте именованные экспорты для утилит
- Группируйте связанные функции в модули
- Используйте `index.ts` для реэкспорта

## Обработка ошибок

### Стратегия обработки ошибок
- Всегда обрабатывайте ошибки API провайдеров
- Используйте early returns для error conditions
- Показывайте пользователю понятные сообщения об ошибках
- Логируйте ошибки для отладки
- Используйте fallback для подсчета токенов (character-based estimation)

### Паттерны обработки
```typescript
// Правильно
try {
  const result = await aiProvider.call(request);
  if (!result.success) {
    return { error: result.message };
  }
  return result.data;
} catch (error) {
  console.error('AI Provider error:', error);
  throw new Error('Failed to process request');
}
```

## Raycast интеграция

### Команды
- Каждая команда должна иметь уникальный ID в `commands.ts`
- Используйте `buildAIConfig()` для создания конфигурации
- Поддерживайте аргументы команд через `RaycastProps`
- Обрабатывайте `launchContext` для передачи данных между командами

### UI компоненты
- Используйте Raycast API компоненты (`Detail`, `Form`, `ActionPanel`)
- Следуйте паттернам Raycast для навигации
- Используйте `showToast` для уведомлений пользователя
- Поддерживайте keyboard shortcuts
- Реализуйте Suspense для асинхронных операций

### Конфигурация
- Все настройки через `package.json` preferences
- Поддерживайте кастомные промпты через Markdown файлы
- Используйте environment variables для API ключей
- Поддерживайте fallback значения для всех настроек

## Производительность

### Оптимизация
- Используйте потоковую передачу для больших ответов
- Оптимизируйте подсчет токенов (кэширование, estimation)
- Минимизируйте количество API вызовов
- Используйте `React.memo` для компонентов где необходимо
- Избегайте излишних useEffect и useState

### Управление состоянием
- Предпочитайте серверные компоненты клиентским
- Используйте локальное состояние для UI
- Применяйте мемоизацию для тяжелых вычислений

## AI провайдеры

### Gemini Integration
- Поддерживайте все модели Gemini (2.0 Flash, 2.5 Flash, 2.5 Pro)
- Обрабатывайте thinking tokens для Gemini Thinking
- Используйте правильную стоимость токенов

### OpenAI Integration
- Поддерживайте GPT-4o, GPT-4o-mini, o1-preview, o1-mini
- Автоматически переключайтесь с o1 на GPT-4o для изображений
- Обрабатывайте reasoning tokens для o1 моделей

### Универсальность
- Реализуйте единый интерфейс для всех провайдеров
- Поддерживайте кастомные OpenAI-совместимые модели
- Обеспечьте graceful fallback между провайдерами

## Тестирование и качество

### Подходы к тестированию
- Тестируйте каждую AI функцию с реальными API
- Проверяйте правильность подсчета токенов
- Тестируйте переключение между моделями
- Валидируйте handling ошибок API

### Код качество
- Следуйте принципам DRY, KISS, YAGNI
- Минимизируйте когнитивную сложность
- Используйте декларативный подход
- Документируйте сложную бизнес-логику JSDoc

### Backward compatibility
- Поддерживайте совместимость с предыдущими версиями
- Предупреждайте о deprecated функциях
- Обеспечьте плавную миграцию настроек

## Документация

### Комментарии и JSDoc
- Документируйте все публичные API с JSDoc
- Комментируйте сложную бизнес-логику
- Объясняйте неочевидные решения
- Обновляйте README при изменении архитектуры

### Пользовательская документация
- Поддерживайте актуальность README
- Документируйте все доступные команды
- Предоставляйте примеры использования
- Объясняйте настройки и конфигурацию
